/* eslint-disable  func-names */
/* eslint-disable  no-console */

const Alexa = require('ask-sdk-core');
const axios = require('axios');
const phonemes = require('phonemedictionary.json');
const hints = require('hintsdata.json');
const videoList = require('videolist.json');

//To use the skill, provide a tokens file containing the token JSON 
//generated by the Resources/tokengenerator.sh shell script.
const tokens = require('private/tokens.json');

//To use the skill, provide a S3Urls.json file containing locations
//for images
const s3Urls = require('private/S3Urls.json');

//API URIs
const baseApiUri = 'https://owner-api.teslamotors.com';
const getVehiclesUri = '/api/1/vehicles';

//APL Documents
const vehicleStateApl = require('apl/VehicleStateDocument.json');
const videoResponseWithAudioApl = require('apl/VideoResponseWithAudioDocument.json');

const userAgent = 'Nikola Skill/1.0-alpha'
const fallbackSpeechText = 'I don\'t have an answer for that yet';
const errorSpeechText = 'Uh oh! Something went wrong. I logged the error and will work on it tonight.';
const Model3BlueImageUrl = s3Urls.MDL3PPSBImageUrl;

const axiosClient = axios.create({
    baseURL: baseApiUri,
    timeout: 5000,
    headers: {
        'User-Agent': userAgent,
        'Authorization': 'Bearer ' + tokens.access_token
    }
});

const LaunchRequestHandler = {
  canHandle(handlerInput) {
    return handlerInput.requestEnvelope.request.type === 'LaunchRequest';
  },
  async handle(handlerInput) {
    console.log('LaunchRequestHandler' + JSON.stringify(handlerInput.requestEnvelope));
    var skillResponse = await getLaunchResponse(handlerInput);
    console.log('Response: ' + JSON.stringify(skillResponse));
    return skillResponse;
  },
};

const YesIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'AMAZON.YesIntent';
    },
    async handle(handlerInput) {
        console.log('YesIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var speechText = fallbackSpeechText;
        const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
        var skillResponse = null;

        if(sessionAttributes.nextCommand == 'getChargeStatus')
        {
            skillResponse = await getChargeStateResponse(handlerInput, true);
        }
        else if(sessionAttributes.nextCommand == 'wake')
        {
            skillResponse = await wakeCar(handlerInput);
        }

        sessionAttributes.nextCommand = null;
        handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const HonkIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'HonkIntent';
    },
    async handle(handlerInput) {
        console.log('HonkIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = await honkHorn(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const DrivingIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'DrivingIntent';
    },
    async handle(handlerInput) {
        console.log('DrivingIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = await getDrivingIntentResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const ClimateControlIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'ClimateControlIntent';
    },
    async handle(handlerInput) {
        console.log('ClimateControlIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = await getClimateControlIntentResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const AutoPilotIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'AutoPilotIntent';
    },
    async handle(handlerInput) {
        console.log('AutoPilotIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = await getAutoPilotIntentResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const ChargeHelpIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'ChargeHelpIntent';
    },
    async handle(handlerInput) {
        console.log('ChargeHelpIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = await getChargeHelpIntentResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const ChargeStatusIntentHandler = {
    canHandle(handlerInput) {
        return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'ChargeStatusIntent';
    },
    async handle(handlerInput) {
        console.log('LaunchRequestHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var speechText = fallbackSpeechText;
        var displayText = fallbackSpeechText;
        const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
        var skillResponse = null;

        try
        {
            var carAttributes = await getFirstCarAttributes();

            if(carAttributes != null)
            {
                //Persist data to session
                persistCarAttributesToSession(sessionAttributes, carAttributes);

                if(isCarAvailable(sessionAttributes.currentTeslaState))
                {
                    skillResponse = getChargeStateResponse(handlerInput, true);
                }
                else
                {
                    sessionAttributes.nextCommand = 'wake';
                    speechText = `Looks like ${sessionAttributes.currentTeslaNamePhoneme} is ${sessionAttributes.currentTeslaState}. Should I wake it up?`;
                    displayText = `Looks like ${sessionAttributes.currentTeslaName} is ${sessionAttributes.currentTeslaState}. Should I wake it up?`;

                    skillResponse =  handlerInput.responseBuilder
                    .speak(speechText)
                    .withSimpleCard(sessionAttributes.currentTeslaName, displayText)
                    .withShouldEndSession(false)
                    .getResponse();
                }

                handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
            }
            else
            {
                speechText = 'Looks like you don\'t own any Tesla vehicles. Goodbye!';

                skillResponse =  handlerInput.responseBuilder
                    .speak(speechText)
                    .withShouldEndSession(true)
                    .getResponse();
            }
        }
        finally
        {
            console.log('Response: ' + JSON.stringify(skillResponse));
            return skillResponse;
        }
    },
};

const HelpIntentHandler = {
  canHandle(handlerInput) {
    return handlerInput.requestEnvelope.request.type === 'IntentRequest'
      && handlerInput.requestEnvelope.request.intent.name === 'AMAZON.HelpIntent';
  },
  handle(handlerInput) {
    const speechText = 'You can say hello to me!';

    return handlerInput.responseBuilder
      .speak(speechText)
      .reprompt(speechText)
      .withSimpleCard('Hello World', speechText)
      .getResponse();
  },
};

const CancelNoAndStopIntentHandler = {
  canHandle(handlerInput) {
    return handlerInput.requestEnvelope.request.type === 'IntentRequest'
      && (handlerInput.requestEnvelope.request.intent.name === 'AMAZON.CancelIntent'
        || handlerInput.requestEnvelope.request.intent.name === 'AMAZON.NoIntent'
        || handlerInput.requestEnvelope.request.intent.name === 'AMAZON.StopIntent');
  },
  handle(handlerInput) {
    const speechText = 'Goodbye!';

    return handlerInput.responseBuilder
      .speak(speechText)
      .withSimpleCard('Goodbye!', speechText)
      .getResponse();
  },
};

const PauseIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'AMAZON.PauseIntent';
    },
    async handle(handlerInput) {
        console.log('PauseIntentHandler' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = getPauseResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const ResumeIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && handlerInput.requestEnvelope.request.intent.name === 'AMAZON.ResumeIntent';
    },
    async handle(handlerInput) {
        console.log('ResumeIntent' + JSON.stringify(handlerInput.requestEnvelope));
        var skillResponse = getPauseResponse(handlerInput);
        console.log('Response: ' + JSON.stringify(skillResponse));
        return skillResponse;
    },
};

const FallbackIntentHandler = {
    canHandle(handlerInput) {
      return handlerInput.requestEnvelope.request.type === 'IntentRequest'
        && (handlerInput.requestEnvelope.request.intent.name === 'AMAZON.FallbackIntent');
    },
    handle(handlerInput) {
      const speechText = 'I don\'t know the answer to that. Say Cancel or Exit to exit the Tesla skill. You can ask Alexa that question once you exit';
  
      return handlerInput.responseBuilder
        .speak(speechText)
        .withSimpleCard('Uh oh!', speechText)
        .withShouldEndSession(false)
        .getResponse();
    },
  };

const SessionEndedRequestHandler = {
  canHandle(handlerInput) {
    return handlerInput.requestEnvelope.request.type === 'SessionEndedRequest';
  },
  handle(handlerInput) {
    console.log(`Session ended with reason: ${handlerInput.requestEnvelope.request.reason}`);

    return handlerInput.responseBuilder.getResponse();
  },
};

const ErrorHandler = {
  canHandle() {
    return true;
  },
  handle(handlerInput, error) {
    console.log(`Error handled: ${error.message}`);

    return handlerInput.responseBuilder
      .speak('Sorry, I can\'t understand the command. Please say again.')
      .reprompt('Sorry, I can\'t understand the command. Please say again.')
      .getResponse();
  },
};

async function getDrivingIntentResponse(handlerInput)
{
    var videoDocumentDatasources = new Object();
    videoDocumentDatasources.videoResponseData = videoList.videoResponses.drivingIntentResponse;
    videoDocumentDatasources.hintsData = hints.hintsData;

    return getVideoResponse(handlerInput, videoDocumentDatasources);
}

async function getClimateControlIntentResponse(handlerInput)
{
    var videoDocumentDatasources = new Object();
    videoDocumentDatasources.videoResponseData = videoList.videoResponses.climateControlIntentResponse;
    videoDocumentDatasources.hintsData = hints.hintsData;

    return getVideoResponse(handlerInput, videoDocumentDatasources);
}

async function getAutoPilotIntentResponse(handlerInput)
{
    var videoDocumentDatasources = new Object();
    videoDocumentDatasources.videoResponseData = videoList.videoResponses.autoPilotIntentResponse;
    videoDocumentDatasources.hintsData = hints.hintsData;

    return getVideoResponse(handlerInput, videoDocumentDatasources);
}

async function getChargeHelpIntentResponse(handlerInput)
{
    var videoDocumentDatasources = new Object();
    videoDocumentDatasources.videoResponseData = videoList.videoResponses.chargeHelpIntentResponse;
    videoDocumentDatasources.hintsData = hints.hintsData;

    return getVideoResponse(handlerInput, videoDocumentDatasources);
}

function getVideoResponse(handlerInput, videoDocumentDatasources)
{
    var speechText = errorSpeechText;

    try
    {
        if(supportsAPL(handlerInput))
        {
            handlerInput.responseBuilder
            .addDirective({
                type: 'Alexa.Presentation.APL.RenderDocument',
                token: 'videoResponseWithAudio',
                document: videoResponseWithAudioApl,
                datasources: videoDocumentDatasources
                })

            if(videoDocumentDatasources.videoResponseData.properties.hasAudio == false)
            {
                handlerInput.responseBuilder
                .addDirective(
                    {
                        type: 'Alexa.Presentation.APL.ExecuteCommands',
                        token: 'videoResponseWithAudio',
                        commands: [
                            {
                                "type": "SpeakItem",
                                "componentId": "Narrative",
                                "highlightMode": "line",
                                "align": "visible"
                            },
                            {
                                "type": "SetValue",
                                "componentId": "Narrative",
                                "property": "display",
                                "value": "none"
                            },
                            {
                                "type": "ControlMedia",
                                "command": "play",
                                "componentId": "VideoPlayer"
                            },
                            {
                                "type": "AutoPage",
                                "componentId": "HintPager",
                                "duration": 6000
                            }
                        ]
                    });
            }
            else
            {
                handlerInput.responseBuilder
                .addDirective(
                    {
                        type: 'Alexa.Presentation.APL.ExecuteCommands',
                        token: 'videoResponseWithAudio',
                        commands: [
                            {
                                "type": "AutoPage",
                                "componentId": "HintPager",
                                "duration": 6000
                            }
                        ]
                    });
            }
        }
        else
        {
            handlerInput.responseBuilder
            .speak(videoList.videoResponses.autoPilotIntentResponse.description);
        }

        return handlerInput.responseBuilder.getResponse();
    }
    catch(error)
    {
        console.log ('getVideoResponse error: ' + error);
        console.log ('getVideoResponse request: ' + JSON.stringify(error.request));

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

function getPauseResponse(handlerInput)
{
    var speechText = errorSpeechText;

    try
    {
        if(supportsAPL(handlerInput))
        {
            handlerInput.responseBuilder
                .addDirective(
                    {
                        type: 'Alexa.Presentation.APL.ExecuteCommands',
                        token: 'videoResponseWithAudio',
                        commands: [
                            {
                                "type": "ControlMedia",
                                "componentId": "VideoPlayer",
                                "command": "pause"
                            }
                        ]
                    });
        }
        else
        {
            handlerInput.responseBuilder
            .speak("This device can not play video.");
        }

        return handlerInput.responseBuilder.getResponse();
    }
    catch(error)
    {
        console.log ('getPauseResponse error: ' + error);
        console.log ('getPauseResponse request: ' + JSON.stringify(error.request));

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

function getResumeResponse(handlerInput)
{
    var speechText = errorSpeechText;

    try
    {
        if(supportsAPL(handlerInput))
        {
            handlerInput.responseBuilder
                .addDirective(
                    {
                        type: 'Alexa.Presentation.APL.ExecuteCommands',
                        token: 'videoResponseWithAudio',
                        commands: [
                            {
                                "type": "ControlMedia",
                                "componentId": "VideoPlayer",
                                "command": "play"
                            }
                        ]
                    });
        }
        else
        {
            handlerInput.responseBuilder
            .speak("This device can not play video.");
        }

        return handlerInput.responseBuilder.getResponse();
    }
    catch(error)
    {
        console.log ('getResumeResponse error: ' + error);
        console.log ('getResumeResponse request: ' + JSON.stringify(error.request));

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

function persistCarAttributesToSession(sessionAttributes, carAttributes)
{
    if(carAttributes != null)
    {
        //Persist data to session
        sessionAttributes.currentTeslaId = carAttributes.currentTeslaId;
        sessionAttributes.currentTeslaName = carAttributes.currentTeslaName;
        sessionAttributes.currentTeslaState = carAttributes.currentTeslaState;
        sessionAttributes.currentTeslaNamePhoneme = carAttributes.currentTeslaNamePhoneme;
    }
}

async function getFirstCarAttributes()
{
    var carAttributes = null;

    try
    {
        var response = await axiosClient.get(getVehiclesUri);
        console.log('GetVehicles response ' + JSON.stringify(response.data));

        if(response.data.count == 0)
        {
            console.log('No Tesla vehicles owned.');
            return carAttributes;
        }

        console.log(response.data.count + ' Tesla vehicles owned.');
        var firstVehicle = response.data.response[0];

        //Set up car attributes
        carAttributes = new Object();
        carAttributes.currentTeslaId = firstVehicle.id;
        carAttributes.currentTeslaName = firstVehicle.display_name;
        carAttributes.currentTeslaState = firstVehicle.state;
        carAttributes.currentTeslaNamePhoneme = getPhoneme(carAttributes.currentTeslaName);
    }
    catch(error)
    {
        logErrorInformation('getFirstVehicleProperties', error);
    }
    
    console.log('Returning carAttributes');
    return carAttributes;
}

async function getLaunchResponse(handlerInput)
{
    try
    {
        var speechText = fallbackSpeechText;
        const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
        var skillResponse = null;
        var carAttributes = await getFirstCarAttributes();

        if(carAttributes != null)
        {
            console.log('carAttributes is not null');
            var vehicleStateDatasource = new Object();
            vehicleStateDatasource.hintsData = hints.hintsData;
            vehicleStateDatasource.vehicleDisplayData = new Object();

            //Persist data to session
            persistCarAttributesToSession(sessionAttributes, carAttributes);

            speechText = `Looks like ${sessionAttributes.currentTeslaNamePhoneme} is ${sessionAttributes.currentTeslaState}.`;
            vehicleStateDatasource.vehicleDisplayData.name = sessionAttributes.currentTeslaName;
            vehicleStateDatasource.vehicleDisplayData.state = sessionAttributes.currentTeslaState;
            vehicleStateDatasource.vehicleDisplayData.imageUrl = Model3BlueImageUrl;
            vehicleStateDatasource.vehicleDisplayData.chargeDataAvailable = false;

            if(isCarAvailable(sessionAttributes.currentTeslaState))
            {
                sessionAttributes.nextCommand = 'getChargeStatus';
                speechText += ` Do you want to know ${sessionAttributes.currentTeslaNamePhoneme} charge status?`;
            }
            else
            {
                sessionAttributes.nextCommand = 'wake';
                speechText += ` Do you want me to try waking up ${sessionAttributes.currentTeslaNamePhoneme}?`;
            }

            handlerInput.responseBuilder
                .speak(speechText)
                .withShouldEndSession(false);

            if(supportsAPL(handlerInput))
            {
                handlerInput.responseBuilder
                .addDirective({
                    type: 'Alexa.Presentation.APL.RenderDocument',
                    token: 'vehicleData',
                    document: vehicleStateApl,
                    datasources: vehicleStateDatasource
                    });
            }

            handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
            skillResponse =  handlerInput.responseBuilder.getResponse();
        }
        else
        {
            console.log('carAttributes is null');
            speechText = 'Looks like you don\'t own any Tesla vehicles. Goodbye!';

            skillResponse =  handlerInput.responseBuilder
                .speak(speechText)
                .withShouldEndSession(true)
                .getResponse();
        }
    }
    catch(error)
    {
        logErrorInformation('LaunchRequestHandler', error);
    }
    finally
    {
        return skillResponse;
    }
}

async function getChargeStateResponse(handlerInput, clearNextCommand)
{
    var skillResponse = null;
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    var id = sessionAttributes.currentTeslaId;
    const chargeStateUri = `/api/1/vehicles/${id}/data_request/charge_state`;
    var speechText = errorSpeechText;

    try
    {
        var response = await axiosClient.get(chargeStateUri);
        console.log('ChargeState response ' + JSON.stringify(response.data));
        var chargeResponse = response.data.response;

        //Persist session attributes
        sessionAttributes.battery_range = chargeResponse.battery_range;
        sessionAttributes.battery_level = chargeResponse.battery_level;
        sessionAttributes.charging_state = chargeResponse.charging_state;
        sessionAttributes.time_to_full_charge = chargeResponse.time_to_full_charge;
        sessionAttributes.timeRemainingToFullCharge = convertDecimalTimeRangeToString(sessionAttributes.time_to_full_charge);
        if(clearNextCommand)
        {
            sessionAttributes.nextCommand = null;
        }
        handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
        
        speechText = `${sessionAttributes.currentTeslaNamePhoneme} has a range of ` + 
        `${sessionAttributes.battery_range} miles. It is currently ${sessionAttributes.charging_state}`;

        if(sessionAttributes.time_to_full_charge != null &&
            sessionAttributes.time_to_full_charge > 0)
        {
            speechText += ' and should be done in ' + sessionAttributes.timeRemainingToFullCharge;            
        }

        var vehicleStateDatasource = new Object();
        vehicleStateDatasource.hintsData = hints.hintsData;
        vehicleStateDatasource.vehicleDisplayData = new Object();
        vehicleStateDatasource.vehicleDisplayData.name = sessionAttributes.currentTeslaName;
        vehicleStateDatasource.vehicleDisplayData.state = sessionAttributes.charging_state;
        vehicleStateDatasource.vehicleDisplayData.imageUrl = Model3BlueImageUrl;
        vehicleStateDatasource.vehicleDisplayData.chargeDataAvailable = true;
        vehicleStateDatasource.chargeData = new Object();
        vehicleStateDatasource.chargeData.batteryLevel = sessionAttributes.battery_level;
        vehicleStateDatasource.chargeData.batteryRange = sessionAttributes.battery_range;
        vehicleStateDatasource.chargeData.timeRemaining = sessionAttributes.timeRemainingToFullCharge;
        
        handlerInput.responseBuilder
            .speak(speechText);

        if(supportsAPL(handlerInput))
        {
            handlerInput.responseBuilder
            .addDirective({
                type: 'Alexa.Presentation.APL.RenderDocument',
                token: 'vehicleData',
                document: vehicleStateApl,
                datasources: vehicleStateDatasource
                })
            .addDirective(
                {
                    type: 'Alexa.Presentation.APL.ExecuteCommands',
                    token: 'vehicleData',
                    commands: [
                        {
                            "type": "AutoPage",
                            "componentId": "HintPager",
                            "duration": 6000
                        }
                    ]
                });
        }

        return handlerInput.responseBuilder.getResponse();
    }
    catch(error)
    {
        console.log ('ChargeState error: ' + error);
        console.log ('ChargeState request: ' + JSON.stringify(error.request));

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

async function wakeCar(handlerInput)
{
    var skillResponse = null;
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    var id = sessionAttributes.currentTeslaId;
    const wakeUri = `/api/1/vehicles/${id}/wake_up`;
    var speechText = errorSpeechText;
    var displayText = errorSpeechText;

    try
    {
        var response = await axiosClient.post(wakeUri);
        console.log('Wake response ' + JSON.stringify(response.data));
        var wakeResponse = response.data.response;

        //Persist session attributes
        sessionAttributes.currentTeslaId = wakeResponse.id;
        sessionAttributes.currentTeslaName = wakeResponse.display_name;
        sessionAttributes.currentTeslaNamePhoneme = getPhoneme(sessionAttributes.currentTeslaName);
        sessionAttributes.currentTeslaState = wakeResponse.state;
        sessionAttributes.nextCommand = 'chargeStatus';
        handlerInput.attributesManager.setSessionAttributes(sessionAttributes);
        
        if(isCarAvailable(sessionAttributes.currentTeslaState))
        {
            speechText = `${sessionAttributes.currentTeslaNamePhoneme} is now ${sessionAttributes.currentTeslaState}.` +
                            ` Did you want me to get the charging status?`;

            displayText = `${sessionAttributes.currentTeslaName} is now ${sessionAttributes.currentTeslaState}.` +
            ` Did you want me to get the charging status?`;

            return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard(sessionAttributes.currentTeslaName, displayText)
            .withShouldEndSession(false)
            .getResponse();
        }
        else
        {
            speechText = `${sessionAttributes.currentTeslaNamePhoneme} is still waking up.` + 
                            ` Ask me about it again in about 30 seconds.`

            displayText = `${sessionAttributes.currentTeslaName} is still waking up.` + 
            ` Ask me about it again in about 30 seconds.`

            return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard(sessionAttributes.currentTeslaName, displayText)
            .getResponse();
        }
    }
    catch(error)
    {
        logErrorInformation('wakeCar', error);

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

async function honkHorn(handlerInput)
{
    var skillResponse = null;
    const sessionAttributes = handlerInput.attributesManager.getSessionAttributes();
    var id = sessionAttributes.currentTeslaId;
    const honkUri = `/api/1/vehicles/${id}/command/honk_horn`;
    var speechText = errorSpeechText;
    var displayText = errorSpeechText;

    try
    {
        var response = await axiosClient.post(honkUri);
        console.log('Honk response ' + JSON.stringify(response.data));
        var honkResponse = response.data;

        speechText = `I am trying to honk ${sessionAttributes.currentTeslaNamePhoneme}'s horn.`;
        displayText = `I am trying to honk ${sessionAttributes.currentTeslaName}'s horn.`;

        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard(sessionAttributes.currentTeslaName, displayText)
            .withShouldEndSession(false)
            .getResponse();
    }
    catch(error)
    {
        logErrorInformation('hokeHorn', error);

        speechText = errorSpeechText;
        return handlerInput.responseBuilder
            .speak(speechText)
            .withSimpleCard('Oops!', speechText)
            .getResponse();
    }
}

function logErrorInformation(name, error)
{
    console.log (`${name} error: ` + error);
    if (error.response) {
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        console.log(error.response.data);
        console.log(error.response.status);
        console.log(error.response.headers);
    } else if (error.request) {
        // The request was made but no response was received
        // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
        // http.ClientRequest in node.js
        console.log(error.request);
    } else {
        // Something happened in setting up the request that triggered an Error
        console.log('Error', error.message);
    }

    console.log(error.config);
}

function getPhoneme(currentTeslaName)
{
    if(phonemes[currentTeslaName.toLowerCase()] != undefined
        && phonemes[currentTeslaName.toLowerCase()] != null)
    {
        var phoneme = phonemes[currentTeslaName.toLowerCase()];
        return `<phoneme alphabet="ipa" ph="${phoneme}">${currentTeslaName}</phoneme>`;
    }
    else
    {
        return currentTeslaName;
    }
}

function isCarAvailable(currentState)
{
    if(currentState != undefined
    && currentState != null
    && currentState != 'asleep'
    && currentState != 'offline')
    {
        console.log('Car is available');
        return true;
    }
    else
    {
        console.log('Car is not available');
        return false;
    }
}

function supportsAPL(handlerInput) {
    const supportedInterfaces = handlerInput.requestEnvelope.context.System.device.supportedInterfaces;
    const aplInterface = supportedInterfaces['Alexa.Presentation.APL'];
    return aplInterface != null && aplInterface != undefined;
}

function convertDecimalTimeRangeToString(timeRange)
{
    var hours = 0;
    var minutes = 0;
    var timeRangeString = '';

    hours = Math.floor(timeRange);
    minutes = Math.round((timeRange - hours) * 60);

    if(hours > 0)
    {
        timeRangeString += hours + ' hours';
    }

    if(minutes > 0)
    {
        timeRangeString += ' ' + minutes;
        if(minutes > 1)
        {
            timeRangeString += ' minutes';
        }
        else
        {
            timeRangeString += ' minute';
        }
    }

    return timeRangeString;
}

const skillBuilder = Alexa.SkillBuilders.custom();

exports.handler = skillBuilder
  .addRequestHandlers(
    LaunchRequestHandler,
    YesIntentHandler,
    ChargeStatusIntentHandler,
    HonkIntentHandler,
    HelpIntentHandler,
    CancelNoAndStopIntentHandler,
    SessionEndedRequestHandler,
    DrivingIntentHandler,
    ClimateControlIntentHandler,
    AutoPilotIntentHandler,
    ChargeHelpIntentHandler,
    FallbackIntentHandler,
    PauseIntentHandler,
    ResumeIntentHandler
  )
  .addErrorHandlers(ErrorHandler)
  .lambda();
